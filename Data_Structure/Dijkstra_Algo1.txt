/* 
weight: 가중치 그래프의 인접 행렬
S: 시작 정점 v로부터의 최단 경로(거리)가 이미 발견된 정점들의 집합
distance: 시작 정점에서 (집합 S의 정점만을 거친) 다른 정점으로의 최단 경로 거리 기록
distance[v]=0, distance[v의 인접 정점]=weight[v][인접 정점]
시작 정점에서 다른 정점으로의 최단 경로는 반드시 집합 S에 있는 정점만을 거쳐서 구성
*/

//입력: 가중치 그래프 G, 가중치는 음수가 아님.
//출력: distance 배열, distance[u]는 v에서 u까지의 최단 거리(v는 시작 정점)

function shortest_path(G,v) do : 시작 노드 v
    S <- {v} : 최단 경로가 결정된 노드의 집합에 v를 넣는다.
    for(각 정점 w -> G) do
        distance[w] <- weight[v][w] //초기화: v의 인접 정점의 최단 경로는 이미 정해져 있으므로 세팅
    end
    while (모든 정점이 S에 포함되지 않았다면) do //모든 정점이 최단 경로에 포함될 때까지
        u <- 집합 S에 속하지 않는 정점 중에서 최소 distance 정점 //아직 경로가 결정되지 않은 정점 중에서 가장 최소 거리를 갖는 경우, 최단 경로로 확정하여 넣어줌
        //최단 경로가 새로 확정된 노드 u
        S <- S U {u} //u의 최단 경로를 확정해줌
        for(u에 인접하고 S에 없는 각 정점 z) do
            if(distance[u] + weight[u][z] < distance[z]) do //u를 거치고 다른 노드와 연결되는 경로, 그 바깥에 있던 노드 중 u를 거치지 않는 경로 중 더 짧은 걸로 업데이트
                distance[z] <- distance[u] + weight[u][z]
            end
        end
    end
end

//프림: 해당 정점이 최소 스패닝 트리에 포함이 되었는가?! (덩어리 중심 거리->포함되면 거리 0됨)
//다익스트라: 해당 정점이 시작 정점으로부터의 최단 경로 거리가 결정이 되었는가?! (출발점 중심 거리->연결되어도 거리는 합산해야 함). 음수 가중치는 없다고 가정